/*:
[Previous](@previous) | [Next](@next)
***
# 取樣

目標: 從*n*物件中亂數取出*k*個樣品

假設有一疊牌樸克牌共52張，要從中隨機選出10張牌，其演算法如下：

*/
import Foundation

func select<T>(from array: [T], count k: Int) -> [T] {
	var a = array
	for i in 0..<k {
		let r = random(min: i, max: a.count - 1)
		if i != r {
			swap(&a[i], &a[r])
		}
	}
	return Array(a[0..<k])
}

var a = Array(count: 52, repeatedValue: 0)
for i in a.indices {
	a[i] = i + 1
}
a
select(from: a, count: 10)

/*:

通常隨機取樣也會進行洗牌的過程，洗牌演算法會將陣列分為兩部分， selected items; the second region is all the remaining items.

有一個陣列如下：

`[ "a", "b", "c", "d", "e", "f", "g" ]`

要從中隨機取樣3元素，`k = 3`。在圈中，`i`起始值為0，指向`"a"所在的位置`.

`[ "a", "b", "c", "d", "e", "f", "g" ]`

接著在`i`與`a.count`之間取一個亂數值，假設是4，將`"a"`與`"e"`換位，`i`遞增1：

`[ "e" | "b", "c", "d", "a", "f", "g" ]`

此處以`|`來代表分隔兩區域的分界，`"e"`是我們亂數選出的第一樣本，在其後的則是可以再由其中挑出的母體。

再由`i`與`a.count`之間取一個亂數值，因為i會在每次取樣後持續遞增，因此換位的過程不會發生已取樣位置被換位的情況。這次假設亂數值為6，對`"b"`與`"g"`換位：

`[ "e" , "g" | "c", "d", "a", "f", "b" ]`

進行最後一次取亂數，假設是4，進行`"c"`與`"a"`的換位，陣列中`|`左側的三個元素即為亂數取樣的結果。

`[ "e", "g", "a" | "d", "c", "f", "b" ]`

非常容易，對吧。此演算法的時間複雜度為**O(k)**，因為迴圈執行的次數與我們取的樣本數*k*有關。

此處為另一種實作方式，又稱為水庫取樣法：

*/
func reservoirSample<T>(from a: [T], count k: Int) -> [T] {
	precondition(a.count >= k)
	
	var result = [T]()      // 1
	for i in 0..<k {
		result.append(a[i])
	}
	
	for i in k..<a.count {  // 2
		let j = random(min: 0, max: i)
		if j < k {
			result[j] = a[i]
		}
	}
	return result
}
/*:

此實作共分成兩步驟：

1. 將原始母體陣列的前`k`個元素存入到`result`陣列，而此稱為水庫。
2. 隨機地置換水庫中與母體陣列的元素。

此演算法時間複雜度為**O(n)**，比前一演算法慢，其優勢在於應用於非常大的陣列。在取樣後仍要維持母體元素次序的話，使用上述兩個實作方法要特別注意到次序會被破壞的缺點。以下是維持原本元素次序實作方式：

*/
func select1<T>(from a: [T], count requested: Int) -> [T] {
	var examined = 0
	var selected = 0
	var b = [T]()
	
	while selected < requested {                          // 1
		examined += 1
		
		let r = Double(arc4random()) / 0x100000000          // 2
		
		let leftToExamine = a.count - examined + 1          // 3
		let leftToAdd = requested - selected
		
		if Double(leftToExamine) * r < Double(leftToAdd) {  // 4
			selected += 1
			b.append(a[examined - 1])
		}
	}
	return b
}
/*:

此演算法採用機率來決定是否取樣母體中的元素。

1. 迴圈從陣列頭步進到陣列尾，持續到*n*個元素的母體選出*k*個樣本，此處*k*稱為`requested`、*n*則是`a.count`。

2. 計算一個介於0到1的亂數值`0.0 <= r < 1.0`，因為上界值不希望是1，因此除法算式中的分母是`0x100000000`（為`Int32.max + 1`）

3. `leftToExamine`是母體中還沒有檢視過的元素數量，`leftToAdd`則是還需要選出多少元素才完成抽樣。

4. 這段程式碼功能類似硬幣翻面，用以決定是否將目前檢視的元素加入到抽樣的目標陣列中。

此演算法是採用機率算法來決定每個元素是否被選取，有趣之處在於一定確保最後選出的樣本數為*k*個。

讓我們有前面的例子解說一下此演算法：

`[ "a", "b", "c", "d", "e", "f", "g" ]`

迴圈依序檢定每個元素，開始是`"a"`，得到一個0到1間的亂數值，假設是0.841，根據步驟4`// 4`的算式，將其乘以位被檢定元素數：

`7 * 0.841 = 5.887`

將其與3比較，結果是否定，因此`"a"`的樣本選擇檢定是不選取此元素，接著進行`"b"`。取得一亂數假設是0.212，未檢定元素數為6：

`6 * 0.212 = 1.272`

這是比3小，因此`"b"`通過檢定成為樣本。接著是`"c"`，這次亂數假設是0.264：

`5 * 0.264 = 1.32`

待抽樣出的需求數現為2，因此與2做比較，通過檢定，`"c"`也成為樣本。現在已抽出樣本有`[ "b", "c" ]`。現在還有4個待檢定元素與一個待抽出樣本數，假設下一亂數值為0.718：

`4 * 0.718 = 2.872`

要成為被抽樣的樣本條件是算術值小於1，檢定`"d"`的結果為否，因此換下一個，假設亂數值0.346，算術：

`3 * 0.346 = 1.038`

檢定失敗`"e"`也未能被抽樣。只剩下兩個元素未檢定。從算式其實可以觀察到，接下來亂數值是否大於0.5是決定`"f"`是否被選擇的關鍵，若小於，則成為樣本若大於則繼續下一個元素，假設此次亂數是0.583：

`2 * 0.583 = 1.166`

`"f"`檢定失敗，必須檢定最後一個元素，到此很明顯地不論亂數為何，我們都應該要將最後一個元素加入樣本中，否則此演算法便未能達到要求的功能。假設最後這輪亂數是0.999：

`1 * 0.999 = 0.999`

可以看出無論亂數值為何，這次的檢定一定是成功的，最後抽樣的結果為`[ "b", "c", "g" ]`。注意到母體陣列的排序方式並未受到破壞。

可能你會好奇如果運氣非常好（或是說非常背），每次的亂數值都是0.999，這個演算法仍能運作嗎？試試看吧：

	7 * 0.999 = 6.993     < 3? 否
	6 * 0.999 = 5.994     < 3? 否
	5 * 0.999 = 4.995     < 3? 否
	4 * 0.999 = 3.996     < 3? 否
	3 * 0.999 = 2.997     < 3? 是
	2 * 0.999 = 1.998     < 2? 是
	1 * 0.999 = 0.999     < 1? 是

一樣是對的！那是不是代表越在陣列後方的元素被抽樣出的機會越高呢？也不是的，所有的元素都是相同的機率被選取作為樣本。（當然前提是取得亂數的函式本身是真正的亂數）

以下為測試：

*/
let input = [
	"there", "once", "was", "a", "man", "from", "nantucket",
	"who", "kept", "all", "of", "his", "cash", "in", "a", "bucket",
	"his", "daughter", "named", "nan",
	"ran", "off", "with", "a", "man",
	"and", "as", "for", "the", "bucket", "nan", "took", "it",
]

let output = select(from: input, count: 10)
print(output)
print(output.count)

/*:

此實作時間複雜度**O(n)**。


***
[Previous](@previous) | [Next](@next)
*/
